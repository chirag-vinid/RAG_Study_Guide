"""
Flask Backend - Simplified for Study Material Only
Connects frontend → pdf_extracter → RAG pipeline → markdown output
"""

import sys
import os
import asyncio
from threading import Thread

# Fix for asyncio event loop issues on Windows with Flask
if sys.platform == 'win32':
    import asyncio
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

# Set environment variable to avoid ChromaDB threading issues
os.environ['CHROMADB_BACKEND'] = 'duckdb+parquet'

from flask import Flask, request, jsonify, send_file, send_from_directory
from flask_cors import CORS
from werkzeug.utils import secure_filename
import os
from datetime import datetime
import traceback

# Import the simplified RAG pipeline
from main_rag import RAGPipeline

app = Flask(__name__, static_folder='.')
CORS(app)

# Configuration
UPLOAD_FOLDER = 'uploads'
OUTPUT_FOLDER = 'outputs'
EXTRACTED_TEXT_FOLDER = 'extracted_text'
VECTOR_STORE_FOLDER = 'faiss_stores'
ALLOWED_EXTENSIONS = {'pdf', 'docx', 'txt'}
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB

# Create necessary folders
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)
os.makedirs(EXTRACTED_TEXT_FOLDER, exist_ok=True)
os.makedirs(VECTOR_STORE_FOLDER, exist_ok=True)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['OUTPUT_FOLDER'] = OUTPUT_FOLDER
app.config['EXTRACTED_TEXT_FOLDER'] = EXTRACTED_TEXT_FOLDER
app.config['VECTOR_STORE_FOLDER'] = VECTOR_STORE_FOLDER
app.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE


def allowed_file(filename):
    """Check if file extension is allowed"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS


def create_study_guide_markdown(relevant_chunks, metadata, output_path):
    """
    Create a markdown study guide from ALL relevant chunks
    
    Args:
        relevant_chunks: List of ALL relevant text chunks
        metadata: Dict with processing metadata
        output_path: Where to save the markdown file
    """
    
    # Create markdown formatted content
    content = []
    
    # Title
    content.append("# AI Generated Study Guide\n")
    content.append("=" * 80)
    content.append("\n\n")
    
    # Metadata section
    content.append("## Document Information\n\n")
    content.append(f"- **Source File:** {metadata.get('source_file', 'N/A')}\n")
    content.append(f"- **Topics Requested:** {metadata.get('topics', 'N/A')}\n")
    content.append(f"- **Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    content.append(f"- **Total Chunks Analyzed:** {metadata.get('total_chunks', 'N/A')}\n")
    content.append(f"- **Relevant Sections Found:** {len(relevant_chunks)}\n")
    content.append("\n" + "=" * 80 + "\n\n")
    
    # Study Content
    content.append("## Study Content\n\n")
    content.append(f"*The following {len(relevant_chunks)} sections are most relevant to your study topics.*\n\n")
    content.append("---\n\n")
    
    # Add each relevant chunk
    for i, chunk in enumerate(relevant_chunks, 1):
        content.append(f"### Section {i}\n\n")
        content.append(f"{chunk}\n\n")
        content.append("---\n\n")
    
    # Footer
    content.append("\n\n")
    content.append("## Study Tips\n\n")
    content.append("- Review each section thoroughly\n")
    content.append("- Make notes of key concepts\n")
    content.append("- Test yourself on the material\n")
    content.append("- Create flashcards for important terms\n\n")
    content.append("---\n\n")
    content.append("*Generated by RAG-Powered AI Study Planner*\n")
    content.append("*All content extracted from your uploaded study material*\n")
    
    # Write to file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.writelines(content)
    
    print(f"[Flask] Study guide created: {output_path}")
    print(f"[Flask] Contains {len(relevant_chunks)} relevant sections")


@app.route('/')
def serve_frontend():
    """Serve the HTML frontend"""
    return send_from_directory('.', 'index.html')


@app.route('/api/generate', methods=['POST'])
def generate_study_guide():
    """
    Main endpoint to generate study guide
    Expects:
    - file: uploaded PDF file
    - topics: topics to study
    """
    try:
        print("\n" + "="*80)
        print("[Flask] New study guide generation request")
        print("="*80)
        
        # Validate request
        if 'file' not in request.files:
            return jsonify({'error': 'No file uploaded'}), 400
        
        if 'topics' not in request.form:
            return jsonify({'error': 'No topics specified'}), 400
        
        file = request.files['file']
        topics = request.form['topics']
        
        print(f"[Flask] Topics: {topics}")
        
        # Validate file
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        if not allowed_file(file.filename):
            return jsonify({'error': 'Invalid file type. Only PDF, DOCX, and TXT are allowed'}), 400
        
        # Save uploaded file
        filename = secure_filename(file.filename)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_filename = f"{timestamp}_{filename}"
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)
        file.save(file_path)
        
        print(f"[Flask] File saved: {file_path}")
        
        # Initialize RAG pipeline
        print("[Flask] Initializing RAG pipeline...")
        pipeline = RAGPipeline()
        
        # Set up vector store directory
        vector_store_path = os.path.join(
            app.config['VECTOR_STORE_FOLDER'], 
            f"vs_{timestamp}"
        )
        
        # Process document with RAG pipeline
        print("[Flask] Processing document with RAG pipeline...")
        result = pipeline.process_document(
            file_path=file_path,
            topics=topics,
            extracted_text_folder=app.config['EXTRACTED_TEXT_FOLDER'],
            persist_directory=vector_store_path,
            similarity_threshold=0.5  # Adjust this to get more/fewer chunks
        )
        
        if not result['success']:
            raise Exception("RAG pipeline processing failed")
        
        print(f"[Flask] RAG processing complete")
        print(f"[Flask] Total chunks: {result['total_chunks']}")
        print(f"[Flask] Relevant chunks: {result['relevant_count']}")
        print(f"[Flask] Extracted text saved to: {result['extracted_text_file']}")
        
        # Check if we have relevant chunks
        if result['relevant_count'] == 0:
            return jsonify({
                'error': 'No relevant content found for the specified topics. Try different keywords or broader topics.'
            }), 400
        
        # Create markdown study guide with ALL relevant chunks
        output_filename = f"study_guide_{timestamp}.md"
        output_path = os.path.join(app.config['OUTPUT_FOLDER'], output_filename)
        
        print("[Flask] Creating markdown study guide...")
        create_study_guide_markdown(
            relevant_chunks=result['relevant_chunks'],
            metadata={
                'topics': topics,
                'source_file': filename,
                'total_chunks': result['total_chunks'],
                'extracted_text_file': result['extracted_text_file']
            },
            output_path=output_path
        )
        
        print(f"[Flask] Study guide generated successfully: {output_filename}")
        print("="*80 + "\n")
        
        # Return success response
        return jsonify({
            'success': True,
            'message': 'Study guide generated successfully',
            'filename': output_filename,
            'download_url': f'/api/download/{output_filename}',
            'chunks_processed': result['total_chunks'],
            'relevant_chunks': result['relevant_count']
        }), 200
        
    except Exception as e:
        print(f"[Flask ERROR] {str(e)}")
        traceback.print_exc()
        return jsonify({'error': f'Server error: {str(e)}'}), 500


@app.route('/api/download/<filename>', methods=['GET'])
def download_file(filename):
    """Endpoint to download generated study guide"""
    try:
        file_path = os.path.join(app.config['OUTPUT_FOLDER'], secure_filename(filename))
        
        if not os.path.exists(file_path):
            return jsonify({'error': 'File not found'}), 404
        
        return send_file(
            file_path,
            as_attachment=True,
            download_name=filename,
            mimetype='text/markdown'
        )
        
    except Exception as e:
        print(f"[Flask ERROR] Download error: {str(e)}")
        return jsonify({'error': f'Download failed: {str(e)}'}), 500


@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'message': 'RAG Study Guide API is running',
        'mode': 'Study Material Only',
        'using': 'Google Gemini Embeddings'
    }), 200


@app.route('/api/cleanup', methods=['POST'])
def cleanup_old_files():
    """Clean up old uploaded and generated files"""
    try:
        import time
        current_time = time.time()
        cleanup_age = 3600  # 1 hour
        deleted_count = 0
        
        # Clean all folders
        for folder in [app.config['UPLOAD_FOLDER'], 
                      app.config['OUTPUT_FOLDER'],
                      app.config['EXTRACTED_TEXT_FOLDER']]:
            for filename in os.listdir(folder):
                file_path = os.path.join(folder, filename)
                if os.path.isfile(file_path):
                    if current_time - os.path.getmtime(file_path) > cleanup_age:
                        os.remove(file_path)
                        deleted_count += 1
        
        return jsonify({
            'success': True,
            'message': f'Cleaned up {deleted_count} old files'
        }), 200
        
    except Exception as e:
        return jsonify({'error': f'Cleanup failed: {str(e)}'}), 500


if __name__ == '__main__':
    print("\n" + "=" * 80)
    print("RAG STUDY GUIDE BACKEND STARTING...")
    print("=" * 80)
    print(f"Upload folder: {os.path.abspath(UPLOAD_FOLDER)}")
    print(f"Output folder: {os.path.abspath(OUTPUT_FOLDER)}")
    print(f"Extracted text folder: {os.path.abspath(EXTRACTED_TEXT_FOLDER)}")
    print(f"Vector store folder: {os.path.abspath(VECTOR_STORE_FOLDER)}")
    print(f"Mode: Study Material Only")
    print(f"Using: Google Gemini Embeddings with FAISS")
    print(f"Returns: ALL relevant chunks (not limited to top k)")
    print(f"Frontend available at: http://localhost:5000")
    print("=" * 80 + "\n")
    
    # CRITICAL: Use threaded=True with proper async handling
    app.run(debug=True, host='0.0.0.0', port=5000, threaded=True, use_reloader=False)